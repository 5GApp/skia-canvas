"use strict"

const font = require('css-font'),
      {DOMMatrix} = require('./geometry');

//
// Neon <-> Node interface
//

// accessor for calling the rust implementation of a shadowed method
const $ = (obj, s, ...args) =>{
  let fn = Symbol.for(s)
  return obj[fn](...args)
}

// getter/setter maker
const getset = (verb, attr) => {
  let sym = Symbol.for(attr)
  return verb=='set' ? function(val){ this[sym](val) }
       : verb=='get' ? function(){ return this[sym]() }
       : undefined;
}

// shorthand for attaching read-only attributes
const readOnly = (obj, attr, value) => {
  Object.defineProperty(obj, attr, {value, writable:false, enumerable:true})
}

// adjust the prototype of the class generated by the rust code
function RustClass(cls){
  let proto = cls.prototype,
      shadow = (key, rename) => {
        proto[Symbol.for(rename || key)] = proto[key];
        delete proto[key]
      };

  let m, props = {};
  for (let key of Object.getOwnPropertyNames(proto)){
    if (m = key.match(/^([sg]et)_(.*)/)){
      // collect and group all the get_* and set_* methods, renaming them using symbols.
      let [verb, attr] = m.slice(1)
      props[attr] = props[attr] || {}
      props[attr][verb] = getset(verb, key)
      shadow(key)
    }else if (m = key.match(/^_(.*)/)){
      // stow flagged rust Fns behind symbols so they can be called as 'super' methods
      shadow(key, m[1])
    }
  }

  // create a getter/setter property mapping to the collected methods
  for (let [key, prop] of Object.entries(props)) Object.defineProperty(proto, key, prop)

  return cls
}

//
// Helpers to reconcile Skia and DOMMatrixâ€™s disagreement about row/col orientation
//

function toSkMatrix(jsMatrix){
  if (Array.isArray(jsMatrix)){
    var [a, b, c, d, e, f] = jsMatrix
  }else{
    var {a, b, c, d, e, f} = jsMatrix
  }
  return [a, c, e, b, d, f]
}

function fromSkMatrix(skMatrix){
  // TBD: how/if to map the perspective terms
  let [a, c, e, b, d, f, p0, p1, p2] = skMatrix
  return new DOMMatrix([a, b, c, d, e, f])
}

//
// Font string decoding
//

function parseSize(str, stdSize=16){
  let sizes = {
        // proportions from https://www.w3.org/TR/css-fonts-3/#font-size-prop
        "xx-small":3/5, "x-small":3/4, "small":8/9, "smaller":8/9,
        "large":6/5, "larger":6/5, "x-large":3/2, "xx-large":2/1,
      },
      numSize =  /([\d\.]+)(px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q)/,
      namedSize = /(?:x?x-)?small|smaller|medium|larger|(?:x?x-)?large/,
      m;

  if (m = numSize.exec(str)){
    let [size, unit] = [parseFloat(m[1]), m[2]]
    return size * (unit == 'pt' ? 1 / 0.75
                :  unit == '%' ? stdSize / 100
                :  unit == 'pc' ? 16
                :  unit == 'in' ? 96
                :  unit == 'cm' ? 96.0 / 2.54
                :  unit == 'mm' ? 96.0 / 25.4
                :  unit == 'q' ? 96 / 25.4 / 4
                :  unit.match('r?em') ? stdSize
                :  1.0 )
  }

  if (m = namedSize.exec(str)){
    return stdSize * (sizes[m[0]] || 1.0)
  }

  return null
}

function parseWeight(str){
  let m, sizes = { "lighter":300, "normal":400, "bold":700, "bolder":800 },
  numSize =  /\d{3}/,
  namedSize = /normal|bold(er)?|lighter/;

  return (m = numSize.exec(str)) ? parseInt(m[0])
       : (m = namedSize.exec(str)) ? sizes[m[0]]
       : null
}

const featureMap = {
  "normal": [],

  // font-variant-ligatures
  "common-ligatures": ["liga", "clig"],
  "no-common-ligatures": ["-liga", "-clig"],
  "discretionary-ligatures": ["dlig"],
  "no-discretionary-ligatures": ["-dlig"],
  "historical-ligatures": ["hlig"],
  "no-historical-ligatures": ["-hlig"],
  "contextual": ["calt"],
  "no-contextual": ["-calt"],

  // font-variant-position
  "super": ["sups"],
  "sub": ["subs"],

  // font-variant-caps
  "small-caps": ["smcp"],
  "all-small-caps": ["c2sc", "smcp"],
  "petite-caps": ["pcap"],
  "all-petite-caps": ["c2pc", "pcap"],
  "unicase": ["unic"],
  "titling-caps": ["titl"],

  // font-variant-numeric
  "lining-nums": ["lnum"],
  "oldstyle-nums": ["onum"],
  "proportional-nums": ["pnum"],
  "tabular-nums": ["tnum"],
  "diagonal-fractions": ["frac"],
  "stacked-fractions": ["afrc"],
  "ordinal": ["ordn"],
  "slashed-zero": ["zero"],

  // font-variant-east-asian
  "jis78": ["jp78"],
  "jis83": ["jp83"],
  "jis90": ["jp90"],
  "jis04": ["jp04"],
  "simplified": ["smpl"],
  "traditional": ["trad"],
  "full-width": ["fwid"],
  "proportional-width": ["pwid"],
  "ruby": ["ruby"],

  // font-variant-alternates (non-parameterized)
  "historical-forms": ["hist"],
}

const alternatesMap = {
    "stylistic": "salt #",
    "styleset": "ss##",
    "character-variant": "cv##",
    "swash": "swsh #",
    "ornaments": "ornm #",
    "annotation": "nalt #",
}

const featuresRE = new RegExp(`(?<= )(${Object.keys(featureMap).join('|')})(?= )`, 'ig'),
      alternatesRE = new RegExp(`(?<= )(${Object.keys(alternatesMap).join('|')})\\(([0-9]+)\\)(?= )`, 'ig'),
      normalRE = new RegExp(' normal ', 'i'),
      cache = {};

function parseVariant(str){
  if (cache[str]===undefined){
    let raw = ` ${str} `,
        variants = [],
        features = {on:[], off:[]};

    if (normalRE.exec(raw)){
      variants = ['normal'];
    }else{
      for (const match of raw.matchAll(featuresRE)){
        featureMap[match[1]].forEach(feat => {
          if (feat[0] == '-') features.off.push(feat.slice(1))
          else features.on.push(feat)
        })
        variants.push(match[1]);
      }

      for (const match of raw.matchAll(alternatesRE)){
        let subPattern = alternatesMap[match[1]],
            subValue = Math.max(0, Math.min(99, parseInt(match[2], 10))),
            [feat, val] = subPattern.replace(/##/, subValue < 10 ? '0'+subValue : subValue)
                             .replace(/#/, Math.min(9, subValue)).split(' ');
        if (typeof val=='undefined') features.on.push(feat)
        else features[feat] = parseInt(val, 10)
        variants.push(`${match[1]}(${subValue})`)
      }
    }

    if (variants.length){
      // if we didn't get any valid variant names, return undefined
      cache[str] = {variant:variants.join(' '), features:features};
    }
  }

  return cache[str];
}


function parseFont(str){
  try{
    var info = font.parse(str)
  }catch(e){
    e.name = "Warning"
    console.error(e)
    return
  }

  let canonical = font.stringify(info),
      px = parseSize(info.size),
      wt = parseWeight(info.weight),
      leading = parseSize(info.lineHeight, px) || px * 1.2,
      features = info.variant=='small-caps' ? {on:['smcp', 'onum']} : {};

  return Object.assign(info, {px, wt, leading, features, canonical})
}

module.exports = {$, readOnly, RustClass, parseFont, parseVariant, toSkMatrix, fromSkMatrix}