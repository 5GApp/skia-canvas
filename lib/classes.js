"use strict"

var fs = require('fs'),
    {inspect} = require('util'),
    get = require('simple-get'),
    native = require('../native'),
    {DOMMatrix} = require('./geometry'),
    {parseFont, parseVariant, parseFilter} = require('./parse'),
    REPR = inspect.custom

//
// Neon <-> Node interface
//

// accessor for calling the rust implementation of a shadowed method
const $ = (obj, s, ...args) =>{
  let fn = Symbol.for(s)
  return obj[fn](...args)
}

// getter/setter maker
const getset = (verb, attr) => {
  let sym = Symbol.for(attr)
  return verb=='set' ? function(val){ this[sym](val) }
       : verb=='get' ? function(){ return this[sym]() }
       : undefined;
}

// shorthand for attaching read-only attributes
const readOnly = (obj, attr, value) => {
  Object.defineProperty(obj, attr, {value, writable:false, enumerable:true})
}

// adjust the prototype of the class generated by the rust code
function RustClass(cls){
  let proto = cls.prototype,
      shadow = (key, rename) => {
        proto[Symbol.for(rename || key)] = proto[key];
        delete proto[key]
      };

  let m, props = {};
  for (let key of Object.getOwnPropertyNames(proto)){
    if (m = key.match(/^([sg]et)_(.*)/)){
      // collect and group all the get_* and set_* methods, renaming them using symbols.
      let [verb, attr] = m.slice(1)
      props[attr] = props[attr] || {}
      props[attr][verb] = getset(verb, key)
      shadow(key)
    }else if (m = key.match(/^_(.*)/)){
      // stow flagged rust Fns behind symbols so they can be called as 'super' methods
      shadow(key, m[1])
    }
  }

  // create a getter/setter property mapping to the collected methods
  for (let [key, prop] of Object.entries(props)) Object.defineProperty(proto, key, prop)

  return cls
}

//
// Helpers to reconcile Skia and DOMMatrixâ€™s disagreement about row/col orientation
//

function toSkMatrix(jsMatrix){
  if (Array.isArray(jsMatrix)){
    var [a, b, c, d, e, f] = jsMatrix
  }else{
    var {a, b, c, d, e, f} = jsMatrix
  }
  return [a, c, e, b, d, f]
}

function fromSkMatrix(skMatrix){
  // TBD: how/if to map the perspective terms
  let [a, c, e, b, d, f, p0, p1, p2] = skMatrix
  return new DOMMatrix([a, b, c, d, e, f])
}

//
// Extensions to the classes defined in rust (primarily for argument boxing/unboxing)
//

class FontLibrary extends RustClass(native.FontLibrary){
  has(family){
    return this.families.indexOf(family) >= 0
  }
}

const sharedLibrary = new FontLibrary()

class Canvas extends RustClass(native.Canvas){
  static parent = new WeakMap()
  static context = new WeakMap()

  getContext(kind){
    if (kind!="2d") return null
    if (!Canvas.context.has(this)){
      let ctx = new CanvasRenderingContext2D(this, sharedLibrary)
      Canvas.parent.set(ctx, this)
      Canvas.context.set(this, ctx)
    }
    return Canvas.context.get(this)
  }

  [REPR](depth, options) {
    let {width, height} = this
    return `Canvas ${inspect({width, height}, options)}`
  }
}

class CanvasRenderingContext2D extends RustClass(native.CanvasRenderingContext2D){
  get canvas(){ return Canvas.parent.get(this) }

  get currentTransform(){ return fromSkMatrix( $(this, 'get_currentTransform') ) }
  set currentTransform(matrix){  $(this, 'set_currentTransform', toSkMatrix(matrix) ) }
  getTransform(){ return this.currentTransform }
  setTransform(matrix){
    this.currentTransform = arguments.length > 1 ? [...arguments] : matrix
  }

  get font(){ return $(this, 'get_font') }
  set font(str){ $(this, 'set_font', parseFont(str)) }
  get fontVariant(){ return $(this, 'get_fontVariant') }
  set fontVariant(str){ $(this, 'set_fontVariant', parseVariant(str)) }
  measureText(...args){ return new TextMetrics( $(this, 'measureText', ...args) ) }

  get filter(){ return $(this, 'get_filter') }
  set filter(str){ $(this, 'set_filter', parseFilter(str)) }
  createImageData(width, height){ return new ImageData(width, height) }
  getImageData(...args){ return new ImageData( $(this, 'getImageData', ...args) ) }

  createLinearGradient(...args){ return new CanvasGradient("Linear", ...args) }
  createRadialGradient(...args){ return new CanvasGradient("Radial", ...args) }
  createPattern(...args){ return new CanvasPattern(...args) }

  [REPR](depth, options) {
    let props = [ "canvas", "currentTransform", "fillStyle", "strokeStyle", "filter", "font", "direction", "textAlign", "textBaseline",
                  "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled", "imageSmoothingQuality", "shadowBlur", "shadowColor",
                  "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit" ]
    let info = {}
    if (depth > 0 ){
      for (var prop of props){
        try{ info[prop] = this[prop] }
        catch{ info[prop] = undefined }
      }
    }
    return `CanvasRenderingContext2D ${inspect(info, options)}`
  }
}

class Path2D extends RustClass(native.Path2D){
  addPath(path, matrix){
    if (matrix) $(this, 'addPath', path, toSkMatrix(matrix) )
    else $(this, 'addPath', path)
  }
}

class CanvasGradient extends RustClass(native.CanvasGradient){}

class CanvasPattern extends RustClass(native.CanvasPattern){
  setTransform(matrix){
    if (arguments.length>1) matrix = [...arguments]
    $(this, 'setTransform', toSkMatrix(matrix) )
  }
}

class Image extends RustClass(native.Image){
  get src(){ return $(this, "get_src") }
  set src(src){
    var data

    if (Buffer.isBuffer(src)) data = src
    else if (typeof src != 'string') return
    else if (/^\s*data:/.test(src)) {
      // data URI
      let split = src.indexOf(','),
          enc = src.lastIndexOf('base64', split) !== -1 ? 'base64' : 'utf8',
          content = src.slice(split + 1);
      data = Buffer.from(content, enc);
    } else if (/^\s*https?:\/\//.test(src)) {
      // remote URL
      get.concat(src, (err, res, data) => {
        let code = res.statusCode,
            onerror = this.onerror || (() => {}),
            onload = this.onload || (() => {});
        if (err) onerror(err)
        else if (code < 200 || code >= 300) {
          onerror(new Error(`Failed to load image from "${src}" (error ${code})`))
        }else{
          if ($(this, "set_data", data)) onload(this)
          else onerror(new Error("Could not decode image data"))
        }
      })
    } else {
      // local file path
      data = fs.readFileSync(src);
    }

    $(this, "set_src", src)
    if (data){
      let onerror = this.onerror || (() => {}), onload = this.onload || (() => {});
      if ($(this, "set_data", data)) onload(this)
      else onerror(new Error("Could not decode image data"))
    }
  }

  [REPR](depth, options) {
    let {width, height, complete, src} = this
    options.maxStringLength = src.match(/^data:/) ? 128 : Infinity;
    return `Image ${inspect({width, height, complete, src}, options)}`
  }
}

class ImageData extends RustClass(native.ImageData){
  constructor(width, height){
    if (arguments[0] instanceof native.ImageData){
      var {width, height, data} = arguments[0]
    }
    super(width, height)
    let bytes = (this.width * this.height * 4)
    readOnly(this, "data", new Uint8ClampedArray(data && data.buffer || bytes))
  }

  [REPR](depth, options) {
    let {width, height, data} = this
    return `ImageData ${inspect({width, height, data}, options)}`
  }
}

class TextMetrics{
  constructor([
    width, left, right, ascent, descent,
    fontAscent, fontDescent, emAscent, emDescent,
    hanging, alphabetic, ideographic
  ]){
    readOnly(this, "width", width)
    readOnly(this, "actualBoundingBoxLeft", left)
    readOnly(this, "actualBoundingBoxRight", right)
    readOnly(this, "actualBoundingBoxAscent", ascent)
    readOnly(this, "actualBoundingBoxDescent", descent)
    readOnly(this, "fontBoundingBoxAscent", fontAscent)
    readOnly(this, "fontBoundingBoxDescent", fontDescent)
    readOnly(this, "emHeightAscent", emAscent)
    readOnly(this, "emHeightDescent", emDescent)
    readOnly(this, "hangingBaseline", hanging)
    readOnly(this, "alphabeticBaseline", alphabetic)
    readOnly(this, "ideographicBaseline", ideographic)
  }
}



module.exports = {FontLibrary:sharedLibrary, Canvas, CanvasRenderingContext2D, Path2D, Image, ImageData, CanvasGradient, CanvasPattern}